import React from "react";

import { db } from "../Firebase/firebase";
import { set, ref, push, remove } from "firebase/database";

const DBContext = React.createContext({
  writeUserData: () => {},
  readAllUsers: () => {},
  getSingleUser: () => {},
  deleteUser: () => {},
  readAllMessages: () => {},
  updateMessages: () => {},
  removeMessage: () => {},
});

export const DBContextProvider = (props) => {
  const writeUserData = (userId, fullName, email, roles) => {
    // Using set() overwrites data at the specified location, including any child nodes.
    // Since Firebase is essentially a schema-less JSON structure, which is an important part of dynamic real-time data, there is no way to store an empty object/array/null value.

    set(ref(db, "users/" + userId), {
      username: fullName,
      email: email,
      roles,
    });
  };
  const readAllUsers = () => {
    const users = ref(db, "users");
    return users;
  };

  const deleteUser = (uid) => {
    remove(ref(db, `users/${uid}`)); // fucking hell this almost drove me nuts
  };

  // const getSingleUser = (uid) => {
  //   const dbRef = ref(db);
  //   const dbUser = get(child(dbRef, `users/${uid}`));
  //   return dbUser;
  // };
  const getSingleUser = (uid) => {
    const user = ref(db, `users/${uid}`);
    return user;
  };
  // This is an equivalent of an API endpoint, to read,write,update and delete a message
  const message = (uid) => ref(db, `messages/${uid}`); //not being used here currently
  // This endpoint is used  to read all the messages and create a message
  const readAllMessages = () => {
    return ref(db, "messages");
  };

  const updateMessages = (userId, text) => {
    // Create a new message reference with an auto-generated id
    const messageListRef = ref(db, "messages");
    const newMessageRef = push(messageListRef);
    set(newMessageRef, {
      userId,
      text,
    });
  };

  const removeMessage = (uid) => {
    remove(ref(db, `messages/${uid}`)).then(() => {
      console.log("Data removed from databse");
    });
  };
  //   Reading and writing lists
  // Append to a list of data
  // Use the push() method to append data to a list in multiuser applications. The push() method generates a unique key every time a new child is added to the specified Firebase reference. By using these auto-generated keys for each new element in the list, several clients can add children to the same location at the same time without write conflicts. The unique key generated by push() is based on a timestamp, so list items are automatically ordered chronologically.

  // You can use the reference to the new data returned by the push() method to get the value of the child's auto-generated key or set data for the child. The .key property of a push() reference contains the auto-generated key.

  // You can use these auto-generated keys to simplify flattening your data structure. For more information, see the data fan-out example.

  // For example, push() could be used to add a new post to a list of posts in a social application:

  return (
    <DBContext.Provider
      value={{
        writeUserData,
        readAllUsers,
        getSingleUser,
        deleteUser,
        readAllMessages,
        updateMessages,
        removeMessage,
      }}>
      {props.children}
    </DBContext.Provider>
  );
};

export default DBContext;
