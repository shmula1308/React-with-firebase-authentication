import React from "react";

import { db } from "../Firebase/firebase";
import {
  set,
  ref,
  push,
  remove,
  serverTimestamp,
  query,
  orderByChild,
  limitToLast,
  limitToFirst,
  startAt,
  equalTo,
} from "firebase/database";

const DBContext = React.createContext({
  writeUserData: () => {},
  readAllUsers: () => {},
  getSingleUser: () => {},
  deleteUser: () => {},
  readAllMessages: () => {},
  addNewMessage: () => {},
  removeMessage: () => {},
  updateMessage: () => {},
});

export const DBContextProvider = (props) => {
  const writeUserData = (userId, fullName, email, roles) => {
    // Using set() overwrites data at the specified location, including any child nodes.
    // Since Firebase is essentially a schema-less JSON structure, which is an important part of dynamic real-time data, there is no way to store an empty object/array/null value.

    set(ref(db, "users/" + userId), {
      username: fullName,
      email: email,
      roles,
    });
  };
  const readAllUsers = () => {
    const users = ref(db, "users");
    return users;
  };

  const deleteUser = (uid) => {
    remove(ref(db, `users/${uid}`)); // fucking hell this almost drove me nuts. Next you have to figure out how and whether you should also remove all messages associated to the deleted user
  };

  // const getSingleUser = (uid) => {
  //   const dbRef = ref(db);
  //   const dbUser = get(child(dbRef, `users/${uid}`));
  //   return dbUser;
  // };
  const getSingleUser = (uid) => {
    const user = ref(db, `users/${uid}`);
    return user;
  };
  // This is an equivalent of an API endpoint, to read,write,update and delete a message
  const message = (uid) => ref(db, `messages/${uid}`); //not being used here currently
  // This endpoint is used  to read all the messages and create a message

  const readAllMessages = (num) => {
    return query(ref(db, "messages"), orderByChild("createdAt"), limitToLast(num)); // sorting is expensive. Therefore I have specified rules in server side. ".indexOn". You dont have to specify these rules in development. You can pass as many query functions to query, such as limitToLast(), startAt() etc so you get a combination if you need to
  };

  const addNewMessage = (userId, text) => {
    // Create a new message reference with an auto-generated id
    const messageListRef = ref(db, "messages");
    const newMessageRef = push(messageListRef); // push method creates a new auto generated key. newMessageRef has a .key property
    set(newMessageRef, {
      userId,
      text,
      createdAt: serverTimestamp(),
    });
  };

  const updateMessage = (uid, editedMessage) => {
    set(ref(db, "messages/" + uid), editedMessage);
  };

  const removeMessage = (uid) => {
    remove(ref(db, `messages/${uid}`)).then(() => {
      console.log("Data removed from databse");
    });
  };
  //   Reading and writing lists
  // Append to a list of data
  // Use the push() method to append data to a list in multiuser applications. The push() method generates a unique key every time a new child is added to the specified Firebase reference. By using these auto-generated keys for each new element in the list, several clients can add children to the same location at the same time without write conflicts. The unique key generated by push() is based on a timestamp, so list items are automatically ordered chronologically.

  // You can use the reference to the new data returned by the push() method to get the value of the child's auto-generated key or set data for the child. The .key property of a push() reference contains the auto-generated key.

  // You can use these auto-generated keys to simplify flattening your data structure. For more information, see the data fan-out example.

  // For example, push() could be used to add a new post to a list of posts in a social application:

  return (
    <DBContext.Provider
      value={{
        writeUserData,
        readAllUsers,
        getSingleUser,
        deleteUser,
        readAllMessages,
        addNewMessage,
        removeMessage,
        updateMessage,
      }}>
      {props.children}
    </DBContext.Provider>
  );
};

export default DBContext;
